<p><link href="http://kevinburke.bitbucket.org/markdowncss/markdown.css" rel="stylesheet"></link></p>

<p>This files describes the details of manner in which PCAT compiler is compiling AST into assembly code.</p>

<h1>Overview</h1>

<p>The main aim is to compile AST into assembly code. To accomplish this goal, the PCAT compiler will generate file <code>prog.S</code> in <code>gas</code> format, which will later turn into <code>prog.o</code> by gcc.
The entrance and supporting routines would be written in <code>sup.c</code> then turned into <code>sup.o</code> by gcc.
Finally, a call to <code>gcc</code> would generate the executable file <code>prog</code>.</p>

<h1>Assembly</h1>

<p>In this part we are mainly concerning about how to transfer AST into Assembly code.</p>

<p>There's not so-called global variables. All variables are allocated on stack.
To make things simpler, now only (signed) integer and real, both occupying 4-bytes, are supported. Boolean is treated as a 4-byte integer, with 0 representing <code>FALSE</code> and non-zero values <code>TRUE</code>.</p>

<p>The code follows the <strong>cdecl</strong> calling conversion. The static link is passed as the first paramenter to the callee in form of a pointer to the destination frame.
To avoid register allocation, all temporary variables are also stored on the stack, which means
each calculation would take operants from stack, compute, and store the result to the stack.</p>

<h2>Arithmetic operations</h2>

<p>In the following examples, assume that <code>a</code> is stored at <code>-4(%ebp)</code> while <code>b</code> at <code>-8(%ebp)</code></p>

<pre><code>#c=a+b
    movl    -8(%ebp), %eax
    movl    -4(%ebp), %edx 
    addl    %edx, %eax
    movl    %eax, -12(%ebp)
#b=a-b
    movl    -8(%ebp), %eax
    movl    -4(%ebp), %edx
    subl    %eax, %edx
    movl    %edx, %eax
    movl    %eax, -8(%ebp)
#c=a*b
    movl    -4(%ebp), %eax
    imull   -8(%ebp), %eax
    movl    %eax, -12(%ebp)
#c=a div b
    movl    -4(%ebp), %eax
    cltd
    idivl   -8(%ebp)
    movl    %eax, -12(%ebp)
#c=a mod b
    movl    -4(%ebp), %eax
    cltd
    idivl   -8(%ebp)
    movl    %edx, -8(%ebp)
#int-&gt;float
    fildl   -4(%ebp)
    fstps   -12(%ebp)
#c=a/b with(int-&gt;float) a=16(%esp) b=12(%esp)
    fildl   16(%esp)
    fildl   12(%esp)
    fdivrp  %st, %st(1)
    fstps   8(%esp)
</code></pre>

<p>The integer-to-real conversion can be done by <code>fildl</code> instruction.</p>

<h2>Frame</h2>

<p>The <strong>cdecl</strong> calling conversion says that</p>

<blockquote>
  <p>In cdecl, subroutine arguments are passed on the stack. </p>

<p>Integer values and memory addresses are returned in the EAX register, floating point valuesâ€”in the ST0 x87 register. </p>

<p>Registers EAX, ECX, and EDX are caller-saved, and the rest are callee-saved. </p>

<p>The x87 floating point registers ST0 to ST7 must be empty (popped or freed) when calling a new function, and ST1 to ST7 must be empty on exiting a function.</p>
</blockquote>

<h1>Supporting routing</h1>

<p>TODO: the READ/WRITE</p>

<h1>TODO list</h1>

<ul>
<li>Support for array</li>
<li>support for record</li>
</ul>
