
= Extension to AST

* Add "myDef"

( Var ( ID ) ) => ( Var ( ID myDef ) )
( CallSt ( ID expression-list ) ) => ( CallSt ( ID expression-list myDef ) )
( ArrayExp  ( ID array-init-list ) ) => ( ArrayExp  ( ID array-init-list ) )
( RecordExp ( ID record-init-list ) ) => ( RecordExp ( ID record-init-list myDef ) )
( ArrayTyp ( type ) ) => ( ArrayTyp ( type myDef ) )
( RecordTyp ( component-list ) ) => ( RecordTyp ( component-list myDef ) )
myDef is a pointer to ast of definition (VarDec/ProcDec/"Final" Name type???/)


* Add "lexLevel"
( VarDec ( ID type expression ) ) => ( VarDec ( ID type expression lexLevel ) )
( Param ( ID type ) ) => ( Param ( ID type lexLevel ) )
( ProcDec ( ID formal-param-list type body ) ) => 
    ( ProcDec ( ID formal-param-list type body lexLevel ) )
lexLevel is the lexical level where the ID is declared

* Add "currentLevel"
( Var ( ID myDef ) ) =>  ( Var ( ID myDef currentLevel ) )
currentLevel is the lexical level where the ID is used

= Pretty Printing
should I implement it?

= Checking
Walks on AST

* Errors:
ID already defined/not defined
expecting type name "var x : T := 123;"
expecting local/formal name  "y=8*z" ... wait, abandon referece to outer space? good!!!
    *NO* need for dynamic chain!!!!!!!!!!!!!!!!!!
expecting procedure name "w=foo(1,2,3);"
multiple same filed in record
multiple assignment in record constructor
redefine INTEGER/REAL/BOOLEAN/TRUE/FALSE/NIL
    Wait...seems we didn't care about BOOLEAN/TRUE/FALSE?
    Well, treat BOOLEAN as integer, TRUE as 1, FALSE as 0?
    INTEGER/REAL/BOOLEAN are (basic)NameType: new a NamedTyp() for each
    TRUE/FALSE/NIL are constants

* MISC:
type inference: int/float from constance/expression

So...return a pointer to the THING representing the type?


* orders


= coercions
Int to Real...
Mode : integer/real/string/boolean

= Type Checking
Using "TypeDec"