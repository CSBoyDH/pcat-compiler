func          ->    ( IFunc ( func-name space seq ) )
seq           ->    ( ISeq ( {instr} ) )
instr         ->    ( IBinop ( dst op src1[at eax] src2[at edx] ) )
              ->    ( IUnop ( dst op src1 ) )
              ->    ( IReturn ( src1 ) )
              ->    ( ILabel ( label-name ) )
src1/src2     ->    ( ILoad ( reg scope-diff offset ) )
              ->    ( ILoadConst ( const ) )
dst           ->    ( Store ( reg scope-diff offset ) )
const         ->    ( IConstInt ( value ) )
              ->    ( IConstReal ( value ) )
              ->    ( IConstStr ( value ) )
reg           ->    eax/edx
             
func-name/label name are string
value are 4-byte 32-bit integer (the real numbers are also store in this manner)


Ifunc ( func-name seq space ) =
    ILable(_[func-name])
    IProlog(space)
    seq[..]
    IEpilogue

IBinop ( dst op src1 src2 ) = 
    ...

IUnop ( dst op src1 ) =
    ...
    
IReturn ( src1 ) =
    src1
    
ILoad ( reg scope-diff=0 offset ) =
    movl [offset](%ebp),[reg]
    
ILoad ( reg scope-diff>0 offset ) =
    movl 8(%ebp),[reg]
    movl ([reg]),[reg]  // repeat scope-diff - 1 times
    movl [offset]([reg]),[reg]

IStore ( reg scope-diff=0 offset ) =
    movl [reg],[offset](%ebp)
    
IStore ( reg scope-diff>0 offset ) =
    movl 8(%ebp),%ecx
    movl (%ecx),%ecx   // repeat scope-diff - 1 times
    movl [reg],[offset](%ecx)
             
IProloge (space) =         
    pushl   %ebp
    movl    %esp,%ebp    
	andl	$-16, %esp
	subl	$[space], %esp
	andl	$-16, %esp
    
IEpilogue =
    leave
    ret