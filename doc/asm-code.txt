Programs
==========
program is Body ';'
----------
	.globl	main
	.type	main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp
	{Body}
	leave
	ret


Declarations
==========
var VarDecl {VarDecl} (global)
----------
	.globl	a
	.data //仅第一个全局变量需要
	.align 4
	.type	a, @object
	.size	a, 4
a:
	.long	9

var VarDecl {VarDecl} (local)
----------
	subl	$16, %esp
	movl	$9, -4(%ebp)
or
	subl	$40, %esp
	movl	$1, -4(%ebp)
	movl	$0, -24(%ebp)
	movl	$0, -20(%ebp)
	movl	$0, -16(%ebp)
	movl	$0, -12(%ebp)
	movl	$0, -8(%ebp)

//gcc编译时确认大小.....
//其实.可以每次减4?..= =.


procedure ProcedureDecl {ProcedureDecl}
----------
	.globl	a
	.type	a, @function
a:
	pushl	%ebp
	movl	%esp, %ebp
	{Body}
	leave
	ret
//调用时call a即可

Types
==========
Basic Types
----------
#float
(global)
	.globl	a
	.align 4
	.type	a, @object
	.size	a, 4
a:
	.long	1092616192

(local)
	movl	.LC0, %eax
	movl	%eax, -4(%ebp)

	.align 4
.LC0:
	.long	1093664768


#String
	.globl	b
	.section	.rodata
.LC0:
	.string	"10"
	.data
	.align 4
	.type	b, @object
	.size	b, 4
b:
	.long	.LC0

Constructed Types and Type Declarations
----------
#Array
一个一个存到栈里......

#Record
还是一个一个存进去.....
global define:
	.align 4
	.type	b, @object
	.size	b, 8
b:
	.long	1
	.long	1

Expressions
==========
Integer a=-4(%ebp) b=-8(%ebp)
----------
#c=a+b
	movl	-8(%ebp), %eax
	movl	-4(%ebp), %edx 
	addl	%edx, %eax
	movl	%eax, -12(%ebp)
#b=a-b
	movl	-8(%ebp), %eax
	movl	-4(%ebp), %edx
	subl	%eax, %edx
	movl	%edx, %eax
	movl	%eax, -8(%ebp)
#c=a*b
	movl	-4(%ebp), %eax
	imull	-8(%ebp), %eax
	movl	%eax, -12(%ebp)
#c=a div b
	movl	-4(%ebp), %eax
	cltd
	idivl	-8(%ebp)
	movl	%eax, -12(%ebp)
#c=a mod b
	movl	-4(%ebp), %eax
	cltd
	idivl	-8(%ebp)
	movl	%edx, -8(%ebp)
#int->float
	fildl	-4(%ebp)
	fstps	-12(%ebp)
#c=a/b with(int->float) a=16(%esp) b=12(%esp)
	fildl	16(%esp)
	fildl	12(%esp)
	fdivrp	%st, %st(1)
	fstps	8(%esp)

Float d=-12(%ebp) e=-16(%ebp)
----------
#f=d+e
	flds	-12(%ebp)
	fadds	-16(%ebp)
	fstps	-20(%ebp)
#f=d-e
	flds	-12(%ebp)
	fsubs	-16(%ebp)
	fstps	-20(%ebp)
#f=d*e
	flds	-12(%ebp)
	fmuls	-16(%ebp)
	fstps	-20(%ebp)
#f=d/e
	flds	-12(%ebp)
	fdivs	-16(%ebp)
	fstps	-20(%ebp)

Logical operators
----------
#c=a&&b
	cmpl	$0, -4(%ebp)
	je	.L2
	cmpl	$0, -8(%ebp)
	je	.L2
	movl	$1, %eax
	jmp	.L3
.L2:
	movl	$0, %eax
.L3:
	movl	%eax, -12(%ebp)

#c=a||b
	cmpl	$0, -4(%ebp)
	jne	.L2
	cmpl	$0, -8(%ebp)
	je	.L3
.L2:
	movl	$1, %eax
	jmp	.L4
.L3:
	movl	$0, %eax
.L4:
	movl	%eax, -12(%ebp)

#c=!a
	cmpl	$0, -4(%ebp)
	sete	%al
	movzbl	%al, %eax
	movl	%eax, -12(%ebp)

Relational operators
----------
jl jle jg jge je jne

Function call a=f(1,2)
----------
	subl	$24, %esp
	movl	$2, 4(%esp)
	movl	$1, (%esp)
	call	f
	movl	%eax, -4(%ebp)


	.text
	.globl	f
	.type	f, @function
f:
.LFB0:
	pushl	%ebp
	movl	%esp, %ebp
	subl	$16, %esp
	movl	12(%ebp), %eax
	movl	8(%ebp), %edx
	addl	%edx, %eax
	movl	%eax, -4(%ebp)
	movl	-4(%ebp), %eax
	leave
	ret







